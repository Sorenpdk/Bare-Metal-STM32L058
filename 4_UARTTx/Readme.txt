Lessons learned - 
Using an internal oscilator may not be the best choice, as they are inaccurate, this could easily result in UART frame errors.
The data sheet provides tolerance of the USART receiver to clock deviation at page 773
The HSI in our project is not calibrated, but it still works as intended.

FTDI TTL-232R-3v3 works with our board, I thought for sure I needed some kind of voltage level translator, but it worked ?? 
In a daring move I even placed the 5V connection to VCC on the board.
TODO: I should measure the voltage signal level at some point ....

------------ USART TX ---------------
Baud rate = number of bits / second so 115200 is a bit every 1*10^6/115200 = 8.68 uS
As long as we stay below our clock speed we will be fine.
Say we want to run at 115200 baud, the minimum clock we need is 120KHz clock at 8.33 uS per clock cycle.
If we want a baud of 9600 we need to be faster than 104 uS so even a 32KHz clock would be enough at 31.25 uS per clock cycle.


------------ USART RX ---------------
To determine max baud rate, note the oversampling value e.g. 16 .. check that CLK_MCU time > (baudrate time * 16).
Remember to account for tolerances.
If we send a bit every 8.68 uS (baud 115200) and we have to sample that bit 16 times, that means our CLK needs to be faster than 0.54 uS.
As we run our APB2 clock at 12MHz that means we can sample every 83.33 nS so our check is OK.

Say we have a 1MHz clock and a baudrate of 250.000 at 16 oversampling our clock cycle is every 1 uS and we send a bit every 250 nS this will collide, even with a 8 oversampling (500 nS). So we need at least a 2MHz clock and an oversampling of 8 to break even, but this will still result in failure because of the error margin.

The general rule of thumb is 5% error so in our example we need to add 83.33 * 1.05 as our minimum time, clocks arent perfect !


The baud rate does not depend on how many X you oversample. That is just a noise reduction strategy. It does help with speed mismatch but devices with quartz oscillators are not going to have much speed mismatch anyway

https://electronics.stackexchange.com/questions/494292/how-do-you-determine-which-baud-rate-to-choose-its-relation-with-mcu-clock-and

/**
     * set baud rate to 9600
     * 8MHz/(16*9600) = 52.08
     * DIV_Fraction = 16*0.08 = 1.28 -> 1 = 0x1
     * DIC_Mantissa = mantissa(52.08) = 52 = 0x34
     * BRR = 0x341
     */
    USART1->BRR = 0x341;





/** General Info during research 
The commonly used baud rates are 2400 , 4800, 9600, 19.200, 56000, 115200 bauds.

Baud rate generator
The baud rate generator generates a sampling signal whose frequency is exactly 16
times the UART's designated baud rate. To avoid creating a new clock domain and
violating the synchronous design principle, the sampling signal should function as
enable ticks rather than the clock signal to the UART receiver.
For the 19,200 baud rate, the sampling rate has to be 307,200 (i.e., 19,200*16) ticks per
second. Assuming that the system clock rate is 50 MHz(if using Basys2 FPGA kit), the
baud rate generator needs a mod-163 (i.e., counter = clock frequency/samplingfrequency = (5*10^6)/ 307,200) counter, in which a one-clock-cycle tick is asserted
once every 163 clock cycles.


UART receiver
The DBIT constant indicates the number of data bits, and the SB-TICK constant
indicates the number of ticks needed for the stop bits, which is 16, 24, and 32 for 1,
1.5, and 2 stop bits, respectively. DBIT and SB-TICK are assigned to 8 and 16 in this
design.
The chart follows oversampling and includes three major states, start, data, and stop,
which represent the processing of the start bit, data bits, and stop bit. The s-tick signal
is the enable tick from the baud rate generator and there are 16 ticks in a bit interval.
Note that the FSMD stays in the same state unless the s-tick signal is asserted. There
are two counters, represented by the s and n registers. The s register keeps track of the
number of sampling ticks and counts to 7 in the start state, to 15 in the data state, and
to SB-TICK in the stop state. The n register keeps track of the number of data bits
received in the data state. The retrieved bits are shifted into and reassembled in the b
register. A status signal, rx-done-tick, is included. It is asserted for one clock cycle after
the receiving process is completed.


UART Transmitter
The UART transmitter operation is similar to a receiver and it is essentially a shift
register that shifts out data bits at a specific rate. The rate can be controlled by oneclock-cycle enable ticks generated by the baud rate generator. Because no
oversampling is involved, the frequency of the ticks is 16 times slower than that of the
UART receiver. Instead of introducing a new counter, the UART transmitter usually
shares the baud rate generator of the UART receiver and uses an internal counter to
keep track of the number of enable ticks. A bit is shifted out every 16 enable ticks.


Oversampling
The most commonly used sampling rate is 16 times the baud rate, which means that
each serial bit is sampled 16 times. Assume that the communication uses N data bits
and M stop bits. The oversampling scheme works as follows:
1) Wait until the incoming signal becomes 0, the beginning of the start bit, and
then start the sampling tick counter.
2) When the counter reaches 7, the incoming signal reaches the middle point of the
start bit. Clear the counter to 0 and restart.
3) When the counter reaches 15, the incoming signal progresses for one bit and
reaches the middle of the first data bit. Retrieve its value, shift it into a register,
and restart the counter.
4) Repeat step 3 n-1 more times to retrieve the remaining data bits.
5) If the optional parity bit is used, repeat step 3 one time to obtain the parity bit.
6) Repeat step 3 n more times to obtain the stop bits.
The oversampling scheme performs the function of a clock signal. Instead of using the
rising edge to indicate when the input signal is valid, it utilizes sampling ticks to
estimate the middle point of each bit. While the receiver has no information about the
exact onset time of the start bit, the estimation can be off by at most &. The subsequent
data bit retrievals are off by at most & from the middle point as well. Because of the
oversampling, the baud rate can be only a small fraction of the system clock rate, and
thus this scheme is not appropriate for a high data rate **/














/CMSIS contains all core files
- CortexM0+ core <core_cm0plus.h>
- CortexMFunctions <core_cmFunc.h>
- CortexMInstructions <core_cmInstr>

/EWARM contains all project files
- MCU startup assembly instructions <startup_stm32l053xx.s>
- Linker file for flash <stm32l053xx_flash.icf>
- Linker file for SRAM <stm32l053xx_sram>


/Inc contains all include files MCU specific
- stm32l0xx.h
- stm32l0xx_it.h
- stm32l053xx.h
- system_stm32l0xx.h

/Src contains all source files MCU specific
- stm32l0xx_it.c
- system_stm32l0xx

/User contains application code
- main.c


