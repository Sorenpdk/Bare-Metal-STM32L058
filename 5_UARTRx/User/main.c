/**
  ******************************************************************************
  * @file    main.c
  * @author  -
  * @brief   This file implements the following:
  *          - Baremetal implementation using the CMSIS library for Cortex-M0+ 
  *            Basic USART Rx example.
  *            
  *          
  ******************************************************************************
 */ 

/* Includes ------------------------------------------------------------------*/
#include "stm32l0xx.h"
#include "customclock.h"
#include "customgpio.h"
#include "customuart.h"

/* Private define ------------------------------------------------------------*/

/* Private function prototypes -----------------------------------------------*/

/**
  * Brief   Main program.
  * Param   None
  * Retval  None
  */
int main(void)
{
  customClock_init();
  SystemCoreClockUpdate();
  customDelay_init(); // SysTick_Config
  customGPIO_init();
  customUSART1_Init();
  
  
  //unsigned char onechar = 'c';
  uint8_t message[] = "hello world\n";

  while (1)
  {
  
    //UART_Send_Char(onechar);
    UART_Send_String(message, sizeof(message));
    customDelay(2);    
    //UART_Receive_Char();
  }
}




/** General Info during research 
The commonly used baud rates are 2400 , 4800, 9600, 19.200, 56000, 115200 bauds.

Baud rate generator
The baud rate generator generates a sampling signal whose frequency is exactly 16
times the UART's designated baud rate. To avoid creating a new clock domain and
violating the synchronous design principle, the sampling signal should function as
enable ticks rather than the clock signal to the UART receiver.
For the 19,200 baud rate, the sampling rate has to be 307,200 (i.e., 19,200*16) ticks per
second. Assuming that the system clock rate is 50 MHz(if using Basys2 FPGA kit), the
baud rate generator needs a mod-163 (i.e., counter = clock frequency/samplingfrequency = (5*10^6)/ 307,200) counter, in which a one-clock-cycle tick is asserted
once every 163 clock cycles.


UART receiver
The DBIT constant indicates the number of data bits, and the SB-TICK constant
indicates the number of ticks needed for the stop bits, which is 16, 24, and 32 for 1,
1.5, and 2 stop bits, respectively. DBIT and SB-TICK are assigned to 8 and 16 in this
design.
The chart follows oversampling and includes three major states, start, data, and stop,
which represent the processing of the start bit, data bits, and stop bit. The s-tick signal
is the enable tick from the baud rate generator and there are 16 ticks in a bit interval.
Note that the FSMD stays in the same state unless the s-tick signal is asserted. There
are two counters, represented by the s and n registers. The s register keeps track of the
number of sampling ticks and counts to 7 in the start state, to 15 in the data state, and
to SB-TICK in the stop state. The n register keeps track of the number of data bits
received in the data state. The retrieved bits are shifted into and reassembled in the b
register. A status signal, rx-done-tick, is included. It is asserted for one clock cycle after
the receiving process is completed.


UART Transmitter
The UART transmitter operation is similar to a receiver and it is essentially a shift
register that shifts out data bits at a specific rate. The rate can be controlled by oneclock-cycle enable ticks generated by the baud rate generator. Because no
oversampling is involved, the frequency of the ticks is 16 times slower than that of the
UART receiver. Instead of introducing a new counter, the UART transmitter usually
shares the baud rate generator of the UART receiver and uses an internal counter to
keep track of the number of enable ticks. A bit is shifted out every 16 enable ticks.


Oversampling
The most commonly used sampling rate is 16 times the baud rate, which means that
each serial bit is sampled 16 times. Assume that the communication uses N data bits
and M stop bits. The oversampling scheme works as follows:
1) Wait until the incoming signal becomes 0, the beginning of the start bit, and
then start the sampling tick counter.
2) When the counter reaches 7, the incoming signal reaches the middle point of the
start bit. Clear the counter to 0 and restart.
3) When the counter reaches 15, the incoming signal progresses for one bit and
reaches the middle of the first data bit. Retrieve its value, shift it into a register,
and restart the counter.
4) Repeat step 3 n-1 more times to retrieve the remaining data bits.
5) If the optional parity bit is used, repeat step 3 one time to obtain the parity bit.
6) Repeat step 3 n more times to obtain the stop bits.
The oversampling scheme performs the function of a clock signal. Instead of using the
rising edge to indicate when the input signal is valid, it utilizes sampling ticks to
estimate the middle point of each bit. While the receiver has no information about the
exact onset time of the start bit, the estimation can be off by at most &. The subsequent
data bit retrievals are off by at most & from the middle point as well. Because of the
oversampling, the baud rate can be only a small fraction of the system clock rate, and
thus this scheme is not appropriate for a high data rate **/


/* https://www.st.com/resource/en/reference_manual/dm00095744-ultralowpower-stm32l0x3-advanced-armbased-32bit-mcus-stmicroelectronics.pdf */

